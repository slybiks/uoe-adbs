package ed.inf.adbs.minibase;

import ed.inf.adbs.minibase.base.*;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Utils {
    private static FileWriter fileWriter;

    public static String join(final Collection<?> c, String delimiter) {
        return c.stream()
                .map(x -> x.toString())
                .collect(Collectors.joining(delimiter));
    }

    /**
     * Filters out elements from the given list that are not instances of the specified class, and returns a list containing
     * only those elements that are instances of the specified class, cast to the specified class type.
     * <p>
     * Used to segregate relational and comparison atoms from the query body.
     *
     * @param list      the list to filter and cast.
     * @param classType the class type to filter and cast the elements to.
     * @param <T>       the generic type of the class type.
     * @return a list containing only those elements from the input list that are instances of the specified class,
     * cast to the specified class type.
     */
    public static <T> List<T> filterAndCast(final List<?> list, final Class<T> classType) {
        return list.stream()
                .filter(classType::isInstance)
                .map(classType::cast)
                .collect(Collectors.toList());
    }

    /**
     * Builds a new Query with renamed terms. If all terms in the query body are variables, returns the original query.
     * <p>
     * Otherwise, generates new variable names for constant terms in the query, and adds comparison atoms to the new
     * query body, where the constant term is replaced by a variable with the generated name.
     *
     * @param sourceQuery the query to be transformed.
     * @return a new Query object with renamed terms.
     */
    public static Query buildNewQueryWithRenamedTerms(final Query sourceQuery) {
        final boolean isAllVariablesInQueryBody = sourceQuery.getBody().stream()
                .allMatch(relationalAtom -> !(relationalAtom instanceof RelationalAtom &&
                        ((RelationalAtom) relationalAtom).getTerms().stream().anyMatch(Constant.class::isInstance)));

        if (isAllVariablesInQueryBody) return sourceQuery;

        Vector<String> existingVariableNames = sourceQuery.getBody().stream()
                .filter(RelationalAtom.class::isInstance)
                .map(RelationalAtom.class::cast)
                .flatMap(relationalAtom -> relationalAtom.getTerms().stream())
                .filter(Variable.class::isInstance)
                .map(Variable.class::cast)
                .map(Variable::getName)
                .distinct()
                .collect(Collectors.toCollection(Vector::new));

        List<Atom> newBody = new ArrayList<>();

        for (Atom atom : sourceQuery.getBody()) {
            if (atom instanceof RelationalAtom) {
                RelationalAtom relationalAtom = (RelationalAtom) atom;
                List<Term> renamedTermsList = new ArrayList<>();

                for (int position = 0; position < relationalAtom.getTerms().size(); position++) {
                    Term term = relationalAtom.getTerms().get(position);

                    Optional<Variable> variableTerm = Optional.ofNullable(term instanceof Variable ? (Variable) term : null);

                    int constantPosition = position;

                    Term renamedTerm = variableTerm.orElseGet(() -> {
                        Variable constantTurnedVariable = new Variable(generateNewVariableName(relationalAtom.getName(), existingVariableNames, constantPosition));
                        existingVariableNames.add(constantTurnedVariable.getName());
                        newBody.add(new ComparisonAtom(constantTurnedVariable, term, ComparisonOperator.EQ));
                        return constantTurnedVariable;
                    });

                    renamedTermsList.add(renamedTerm);
                }
                newBody.add(new RelationalAtom(relationalAtom.getName(), renamedTermsList));
            } else {
                newBody.add(atom);
            }
        }

        return new Query(sourceQuery.getHead(), newBody);
    }

    /**
     * Generates a new variable name for a constant term embedded in a relational atom.
     * The variable name is generated by appending an alphabetic character and a numeric index to the relational atom name, using a given
     * constant position (index of the constant term in the relational atom).
     * <p>
     * The method iteratively increments the numeric index and terminates when an unused variable name is found.
     *
     * @param relationalAtomName    the name of the relational atom for which the variable name is being generated.
     * @param existingVariableNames a list of existing variable names to avoid generating duplicates.
     * @param constantPosition      the alphabet index for the variable name generation.
     * @return a new variable name for the relational atom.
     */
    private static String generateNewVariableName(final String relationalAtomName, final Vector<String> existingVariableNames, final int constantPosition) {
        String[] alphabet = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"};
        int alphabetSize = alphabet.length;

        int alphabetIndex = constantPosition % alphabetSize;
        int numericIndex = constantPosition / alphabetSize;

        String candidateVariableName;

        do {
            candidateVariableName = String.format("%s%c%d", relationalAtomName, alphabet[alphabetIndex], ++numericIndex);
        } while (existingVariableNames.contains(candidateVariableName));

        return candidateVariableName;
    }

    /**
     * This method is used to find the constant from the input tuple to replace the term of a relational atom.
     *
     * @param tuple          the input tuple from which the constant value is to be extracted.
     * @param term           the term to be replaced in the relational atom.
     * @param relationalAtom the relational atom whose term needs to be replaced.
     * @param delta          the offset value for the index of the term in the relational atom.
     * @return the constant from the input tuple that replaces the term of the relational atom.
     * @throws IllegalArgumentException if the detected relational atom term type does not conform to any of the accepted data types.
     */
    private static Constant findConstantFromTupleToReplaceTerm(final Tuple tuple, final Term term, final RelationalAtom relationalAtom, final int delta) {
        if (term instanceof Constant) {
            return (Constant) term;
        }

        if (term instanceof Variable) {
            int index = relationalAtom.getTerms().indexOf(term);
            return (index >= 0 && index + delta < tuple.getRelationalTerms().size()) ? tuple.getRelationalTerms().get(index + delta) : null;
        }

        throw new IllegalArgumentException("The detected comparison atom term type does not conform to any of the accepted data types");
    }

    /**
     * Matches the terms of the given relational atoms to the values in the given tuple.
     * Aims to replace all the relational atom terms with constant values from the given tuple.
     *
     * @param tuple           the tuple to match against.
     * @param term            the term to replace with constants from the tuple.
     * @param relationalAtoms the relational atoms containing the terms to replace.
     * @return an Optional containing a list of the substituted constants if the terms can be mapped to values in the tuple,
     * * otherwise an empty Optional.
     * @throws UnsupportedOperationException if the sum of term sizes in the collective list of relational atoms is not equal to
     *                                       the number of fields in the whole tuple.
     */
    public static Optional<Object> matchTermsToValuesInTuple(final Tuple tuple, final Term term, final List<RelationalAtom> relationalAtoms) {
        int totalAtomTermCount = relationalAtoms.stream().mapToInt(relationalAtom -> relationalAtom.getTerms().size()).sum();

        if (totalAtomTermCount != tuple.getRelationalTerms().size()) {
            throw new UnsupportedOperationException("The sum of term sizes in the joined relational atoms should be equal to the number of fields in the fused tuple");
        }

        AtomicInteger delta = new AtomicInteger();
        List<Constant> substitutedConstants = new ArrayList<>();

        IntStream.range(0, relationalAtoms.size()).forEach(i -> {
            RelationalAtom relationalAtom = relationalAtoms.get(i);

            Optional<Constant> substitutedConstant = Optional.ofNullable(findConstantFromTupleToReplaceTerm(tuple, term, relationalAtom, delta.get()));
            substitutedConstant.ifPresent(substitutedConstants::add);

            delta.set(relationalAtoms.subList(0, i + 1).stream().mapToInt(atom -> atom.getTerms().size()).sum());
        });

        if (substitutedConstants.isEmpty()) {
            return Optional.empty();
        } else {
            return Optional.of(substitutedConstants);
        }
    }

    /**
     * This method creates a new FileWriter object by taking the file name as an input.
     * If the file does not exist, it creates a new file with the given name and sets the FileWriter object to write to this file.
     * If the file already exists, it sets the FileWriter object to overwrite the existing file.
     * If an error occurs while creating the file or initializing the FileWriter object, it throws an exception.
     *
     * @param fileName - the name of the file to be written to.
     * @param fileName
     * @return void, but sets the fileWriter object to the newly created FileWriter instance.
     */
    public static void createFileWriter(final String fileName) {
        File file = new File(fileName);
        try {
            if (!file.exists()) {
                final boolean fileCreated = file.createNewFile();
                if (!fileCreated) {
                    throw new RuntimeException("An error occurred while creating the file");
                }
                fileWriter = new FileWriter(file);
            } else {
                fileWriter = new FileWriter(file, false);
            }
        } catch (IOException e) {
            System.out.println("An error occurred while initialising the file writer");
            e.printStackTrace();
        }
    }

    /**
     * This method returns the FileWriter instance. If the fileWriter object is null (has not been initialised),
     * then it throws an UnsupportedOperationException.
     *
     * @return FileWriter instance
     * @throws UnsupportedOperationException if the fileWriter object is null
     */
    public static FileWriter getFileWriter() {
        if (fileWriter != null) {
            return fileWriter;
        } else {
            throw new UnsupportedOperationException("The file writer has not been instantiated");
        }
    }

}
